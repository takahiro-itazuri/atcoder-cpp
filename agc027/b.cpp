/*
  AtCoder Grand Contest 027
  B - Garbage Collector

  方針
    ゴミはN個あるため、これをすべて拾うにはNXだけのエネルギーが必要です。
    これはゴミを拾う順番には関係ない。

    ロボットはゴミ箱にゴミを捨てに戻った場合、原点に戻っており、拾ったゴミ
    がないこと以外は初期状態と同じことがわかる。
    したがって、合計m台のロボットが同時にゴミを拾い、ゴミを捨てにもどって
    くるエネルギーを最小化することに等しくなる。

    またゴミは帰り際に遠い方から拾った方が最適である。

    ここで、ある１つのロボットに着目したとき、拾うゴミの数をi個とする。
    ゴミは遠い方から順にx_1, x_2, ...の位置にあるとする。
    (1) i = 1のとき
      E = x_1 + 4 * x_1
        = 5 * x_1
    (2) i = 2のとき
      E = x_1 + 4 * (x_1 - x_2) + 9 * x_2
        = 5 * x_1 + 5 * x_2
    (3) 9 = 3のとき
      E = x_1 + 4 * (x_1 - x_2) + 9 * (x_2 - x_3) + 16 * x_3
        = 5 * x_1 + 5 * x_2 + 7 * x_3
    以上の例からもわかるように手前にあるゴミを追加で拾う場合は、i-1個のゴ
    ミを拾うエネルギーに加えて、
      ((i+1)^2 - i^2) * x_i = (2 * i + 1) * x_i
    だけの追加のエネルギーが必要であることがわかる。以下、位置xにあるゴミ
    をi番目に拾うときに追加で必要なエネルギーをE(i,x)とする。

    以上の考察を踏まえると、i<jならばE(i,x)<=E(j,x)であることがわか
    る。つまり、同じ位置にあるゴミに対して、できるだけ少ない数のゴミを持っ
    ているロボットが拾うと効率が良いということになる。
    
    このことは同時に、各ロボットはどこまで遠いゴミを拾いにいくべきかもわか
    る。はじめはすべてのロボットが拾ったゴミは0個であるため、遠いところから
    順番に各ロボットが拾うのが効率が良いことになる。
    
    すべてのロボットの拾ったゴミの数が同じ場合は、次に近くにあるゴミをどの
    ロボットが拾っても必要なエネルギーは変わりません。しかし、こういった場
    合は、なんらかのルールを設けた方が計算が容易になることが多くあります。
    そこで遠い位置から順番にゴミがx_1, x_2, ..., x_Nの位置にあった場合、
    i番目のロボットはn * i番目（n: 整数）の位置のゴミを拾うこととします。
    するとi番目のロボットの必要なエネルギは
      E_i = E(1,x_i) + E(2,x_{2*i}) + ... + E(n,x_{n*i})
    となります。

    以上の方法で計算した場合、O(N^2)の計算量となり、部分点を得ることができ
    る。

    満点回答を得るためには、累積和を用いると、同じ個数を取る際の計算をまとめ
    て行うことができるため、O(N * log(N))で計算できる。
  
  実装
    ロボットの台数がm台のときのコストを計算し、最小となるものを得る。

    注意点はコストが64bit符号付き整数で表せない場合があることである。こうい
    った場合は解は64bit符号付き整数で表せることが暗黙の了解であり、実際にそ
    のようになる。したがって、途中で打ち切りを行う必要がある。
*/

#include<iostream>
#include<vector>
#include<limits>
using namespace std;

long long N, X;
vector<long long> x;
vector<long long> sum;

int main() {
  scanf("%lld%lld", &N, &X);
  x = vector<long long>(N+1);
  sum = vector<long long>(N+1, 0);
  for (int i = 1; i <= N; ++i) {
    scanf("%lld", &x[i]);
    sum[i] = sum[i-1] + x[i];
  }

  long long min_cost = 1e18;
  for (int m = 1; m <= N; ++m) {
    long long cost = m * X;
    for (int offset = N, group = 1; offset >= 0 && cost < min_cost; offset -= m, ++group) {
      int start = max(0, offset - m);
      int end = offset;
      if (group == 1) cost += 5 * (sum[end] - sum[start]);
      else cost += (2 * group + 1) * (sum[end] - sum[start]);
    }
    min_cost = min(min_cost, cost);
  }

  printf("%lld\n", min_cost + N * X);
  return 0;
}
